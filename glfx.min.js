const lerp=(e,t,i)=>(1-i)*e+i*t;class Scroll{constructor(e){this.DOM={main:document.querySelector("main")},this.DOM.scrollable=this.DOM.main.querySelector("div[data-scroll]"),this.docScroll=0,this.scrollToRender=0,this.current=0,this.ease=e.easing,window.innerWidth<768&&(this.ease=.3),this.speed=0,this.speedTarget=0,this.setSize(),this.getScroll(),this.init(),this.style(),this.initEvents()}init(){for(const e in this.renderedStyles)this.current=this.scrollToRender=this.getScroll();this.setPosition(),this.shouldRender=!0}style(){this.DOM.main.style.position="fixed",this.DOM.main.style.width=this.DOM.main.style.height="100%",this.DOM.main.style.top=this.DOM.main.style.left=0,this.DOM.main.style.overflow="hidden"}getScroll(){return this.docScroll=window.pageYOffset||document.documentElement.scrollTop,this.docScroll}initEvents(){window.onbeforeunload=function(){window.scrollTop(0,0)},window.addEventListener("resize",()=>this.setSize()),window.addEventListener("scroll",this.getScroll.bind(this))}setSize(){document.body.style.height=`${this.DOM.scrollable.scrollHeight}px`}setPosition(){(Math.round(this.scrollToRender)!==Math.round(this.current)||this.scrollToRender<10)&&(this.DOM.scrollable.style.transform=`translate3d(0, ${-1*this.scrollToRender}px, 0)`)}render(){this.speed=Math.min(Math.abs(this.current-this.scrollToRender),200)/200,this.speedTarget+=.2*(this.speed-this.speedTarget),this.current=this.getScroll(),this.scrollToRender=lerp(this.scrollToRender,this.current,this.ease),this.setPosition()}}export const vertex="\nvarying vec2 vUv;\nuniform float uTime;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n\n    //newPosition.y += 10. * sin(newPosition.x * 0.8 + uTime);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    vUv = uv;\n}\n",vertexDistort_1="\nvarying vec2 vUv;\nuniform float uTime;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n\n    newPosition.y += 10. * sin(newPosition.x * 0.2 * PI + uTime);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    vUv = uv;\n}\n",vertexDistort_2="\nvarying vec2 vUv;\nuniform float uTime;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n\n    newPosition.z += 10. * sin(newPosition.y * .01 + uTime);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    vUv = uv;\n}\n",vertexDistort_3="\nvarying vec2 vUv;\nuniform float uTime;\nuniform float onScrollDistort;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n    vUv = uv;\n\n    newPosition.y = newPosition.y + (sin(uv.x * PI) * onScrollDistort);\n     \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    \n}\n",vertexDistort_4="\nvarying vec2 vUv;\nuniform float uTime;\nuniform float uHoverState;\nuniform float onScrollDistort;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n\n    newPosition.x += uHoverState * 10. * sin(newPosition.y * .01 + uTime);\n    newPosition.y = newPosition.y + (sin(uv.x * PI) * onScrollDistort);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    vUv = uv;\n}\n",vertexDistort_5="\nvarying float vNoise;\nvarying vec2 vUv;\nuniform float uTime;\nuniform vec2 uHover;\nuniform float uHoverState;\nuniform float onScrollDistort;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n    float dist = distance(uv, uHover);\n    \n\n    newPosition.y = newPosition.y + (sin(uv.x * PI) * onScrollDistort);\n    newPosition.z = uHoverState * 10. * sin(dist * 5. + uTime);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    vNoise = uHoverState * sin(dist * 5. - uTime);\n    vUv = uv;\n}\n",vertexDistort_6="\nvarying float vNoise;\nvarying vec2 vUv;\nuniform float uTime;\nuniform vec2 uHover;\nuniform float uHoverState;\nuniform float onScrollDistort;\nvoid main()\n{\n    float PI = 3.14;\n    vec3 newPosition = position;\n    float dist = distance(uv, uHover);\n    \n\n    newPosition.y = newPosition.y + (sin(uv.x * PI) * onScrollDistort);\n    newPosition.z = uHoverState * 10. * sin(dist * 10.);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n    vNoise = uHoverState * sin(dist * 5. - uTime);\n    vUv = uv;\n}\n",fragment="\nvarying vec2 vUv;\nuniform sampler2D uImage;\nvoid main()\n{\n    vec2 newVuv = vUv;\n    vec4 imageView = texture2D(uImage, newVuv);\n    gl_FragColor = imageView;\n}",fragmentDistort_1="\nvarying vec2 vUv;\nuniform sampler2D uImage;\nuniform float uTime;\nvoid main()\n{\n    vec2 newVuv = vUv;\n    newVuv = vec2(newVuv.x , newVuv.y + 0.02 * sin(newVuv.x * 2.0 + uTime));\n    vec4 imageView = texture2D(uImage, newVuv);\n    gl_FragColor = imageView;\n}",fragmentDistort_2="\nvarying vec2 vUv;\nvarying float vNoise;\nuniform sampler2D uImage;\nuniform float uHoverState;\nuniform float uTime;\nvoid main()\n{\n    vec2 newVuv = vUv;\n    newVuv = vec2(newVuv.x , newVuv.y + 0.02 * sin(newVuv.x * 2.0 + uTime));\n\n    vec2 p = newVuv;\n    float x = uHoverState;\n    x = smoothstep(.0, 1., (x * 3.0 + p.y-1.0));\n    vec4 first = mix(\n        texture2D(uImage, (p - .5) * (1. - x)+ .5),\n        texture2D(uImage, (p - .5) * x + .5), x);\n\n\n    //vec4 imageView = texture2D(uImage, newVuv);\n    gl_FragColor = first;\n}",fragmentDistort_3="\nvarying vec2 vUv;\nvarying float vNoise;\nuniform sampler2D uImage;\nuniform sampler2D uImage_11;\nuniform float uHoverState;\nuniform float uTime;\nvoid main()\n{\n    vec2 newVuv = vUv;\n    \n\n    vec2 p = newVuv;\n    float x = uHoverState;\n    x = smoothstep(.0, 1., (x * 3.0 + p.y-1.0));\n    vec4 first = mix(\n        texture2D(uImage, (p - .5) * (1. - x)+ .5),\n        texture2D(uImage, (p - .5) * x + .5), x);\n\n\n    //vec4 imageView = texture2D(uImage, newVuv);\n    gl_FragColor = first;\n    gl_FragColor.rgb += 0.08 * vec3(vNoise);\n}",fragmentDistort_4="\nvarying vec2 vUv;\nvarying float vNoise;\nuniform sampler2D uImage;\nuniform sampler2D uImage_11;\nuniform float uHoverState;\nuniform float uTime;\nvoid main()\n{\n    vec2 newVuv = vUv;\n    \n\n    vec2 p = newVuv;\n    float x = uHoverState;\n    x = smoothstep(.0, 1., (x * 3.0 - p.y-1.0));\n    vec4 first = mix(\n        texture2D(uImage, (p - 1.5) * (1. - x)+ .5),\n        texture2D(uImage, (p - .5) * x + .5), x);\n\n\n    //vec4 imageView = texture2D(uImage, newVuv);\n    gl_FragColor = first;\n    gl_FragColor.rgb += 0.08 * vec3(vNoise);\n}";export default class glfx{constructor(e){this.canvas=document.querySelector("#canvas"),this.canvas.style.width="100%",this.canvas.style.height="100vh",this.canvas.style.position="fixed",this.canvas.style.zIndex="-1",this.canvas.style.top=this.canvas.style.left=0,this.canvas.style.overflow="hidden",window.innerWidth<768&&(this.canvas.style.opacity=0),this.time=0,this.container=e.dom,this.width=this.container.offsetWidth,this.height=this.container.offsetHeight,this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(70,this.width/this.height,100,2e3),this.camera.position.z=600,this.camera.fov=2*Math.atan(this.height/2/600)*(180/Math.PI),this.renderer=new THREE.WebGLRenderer({antialias:!0,alpha:!0}),this.renderer.setSize(this.width,this.height),this.container.appendChild(this.renderer.domElement),this.images=[...document.querySelectorAll("img")],this.currScroll=0,this.raycaster=new THREE.Raycaster,this.mouse=new THREE.Vector2,this.scroll=new Scroll(e),this.addImages(e),this.setPosition(),this.mouseMovement(),this.resize(),this.setupResize(),this.render(e)}setupResize(){window.addEventListener("resize",this.resize.bind(this))}resize(){this.width=this.container.offsetWidth,this.height=this.container.offsetHeight,this.renderer.setSize(this.width,this.height),this.camera.aspect=this.width/this.height,this.camera.updateProjectionMatrix()}addImages(e){this.material=new THREE.ShaderMaterial({uniforms:{uTime:{value:0},uImage:{value:0},uHover:{value:new THREE.Vector2(.5,.5)},uHoverState:{value:0},onScrollDistort:{value:0}},vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,wireframe:e.wireFrame}),this.materials=[],this.imageStore=this.images.map(t=>{let i=t.getBoundingClientRect();t.style.opacity=0,window.innerWidth<768&&(t.style.opacity=1),t.style.cursor="pointer";let n=new THREE.PlaneBufferGeometry(i.width,i.height,e.widthSegment,e.heightSegment),o=new THREE.Texture(t);o.needsUpdate=!0;let s=this.material.clone();t.addEventListener("mouseenter",()=>{gsap.to(s.uniforms.uHoverState,1,{value:1})}),t.addEventListener("mouseout",()=>{gsap.to(s.uniforms.uHoverState,1,{value:0})}),this.materials.push(s),s.uniforms.uImage.value=o;let r=window.pageYOffset,a=e.bending;!function e(){let t=window.pageYOffset,i=1*(t-r);gsap.to(s.uniforms.onScrollDistort,a,{value:i}),r=t,requestAnimationFrame(e)}();let l=new THREE.Mesh(n,s);return this.scene.add(l),{img:t,mesh:l,top:i.top,left:i.left,width:i.width,height:i.height}})}setPosition(){this.imageStore.forEach(e=>{e.mesh.position.y=this.currScroll-e.top+this.height/2-e.height/2,e.mesh.position.x=e.left-this.width/2+e.width/2})}mouseMovement(){window.addEventListener("mousemove",e=>{this.mouse.x=e.clientX/this.width*2-1,this.mouse.y=-e.clientY/this.height*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const t=this.raycaster.intersectObjects(this.scene.children);t.length>0&&(t[0].object.material.uniforms.uHover.value=t[0].uv)},!1)}render(e){this.time+=.05,this.scroll.render(),this.currScroll=this.scroll.scrollToRender,this.setPosition(),this.materials.forEach(e=>{e.uniforms.uTime.value=this.time}),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render.bind(this))}}